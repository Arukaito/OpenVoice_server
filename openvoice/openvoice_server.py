import os
import torch
import se_extractor
import io
import magic

from fastapi import FastAPI, UploadFile, File, HTTPException
from starlette.responses import FileResponse
from typing import Optional
from pydantic import BaseModel

from api import BaseSpeakerTTS, ToneColorConverter

app = FastAPI()

# Initialize OpenVoice models
ckpt_base = 'checkpoints/base_speakers/EN'
ckpt_converter = 'checkpoints/converter'
device = "cuda:0" if torch.cuda.is_available() else "cpu"
base_speaker_tts = BaseSpeakerTTS('checkpoints/base_speakers/EN/config.json', device=device)
base_speaker_tts.load_ckpt('checkpoints/base_speakers/EN/checkpoint.pth')
tone_color_converter = ToneColorConverter('checkpoints/converter/config.json', device=device)
tone_color_converter.load_ckpt('checkpoints/converter/checkpoint.pth')

output_dir = 'outputs'
os.makedirs(output_dir, exist_ok=True)

source_se = torch.load(f'{ckpt_base}/en_default_se.pth').to(device)


class SynthesizeSpeechRequest(BaseModel):
    text: str
    voice: Optional[str] = 'default_voice.wav'
    style: Optional[str] = 'default'


@app.post("/upload_audio/")
async def upload_audio(file: UploadFile = File(...)):
    """
    Upload an audio file for later use as the reference audio.

    :param file: The audio file to be uploaded.
    :type file: UploadFile
    :return: Confirmation of successful upload.
    :rtype: dict
    """
    try:
        contents = await file.read()

        allowed_extensions = {'wav', 'mp3', 'flac', 'ogg'}
        max_file_size = 5 * 1024 * 1024  # 5MB

        if not file.filename.split('.')[-1] in allowed_extensions:
            return {"error": "Invalid file type. Allowed types are: wav, mp3, flac, ogg"}

        if len(contents) > max_file_size:
            return {"error": "File size is over limit. Max size is 5MB."}

        # Note: we need to first write the file in order to check magic.
        temp_file = io.BytesIO(contents)
        file_format = magic.from_buffer(temp_file.read(), mime=True)

        if 'audio' not in file_format:
            return {"error": "Invalid file content."}

        # Make sure the resources directory exists
        os.makedirs("resources", exist_ok=True)

        with open(f"resources/{file.filename}", "wb") as f:
            f.write(contents)
        return {"message": f"File {file.filename} uploaded successfully."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/synthesize_speech/")
async def synthesize_speech(request: SynthesizeSpeechRequest):
    """
    Synthesize speech from text using a specified voice and style.

    :param request: The request parameters.
    :type request: SynthesizeSpeechRequest
    :return: Confirmation of successful synthesis.
    :rtype: dict
    """
    try:
        reference_speaker = f'resources/{request.voice}'

        target_se, audio_name = se_extractor.get_se(reference_speaker, tone_color_converter, target_dir='processed', vad=True)
        save_path = f'{output_dir}/output_en_default.wav'

        # Run the base speaker tts
        text = "This audio is generated by OpenVoice."
        src_path = f'{output_dir}/tmp.wav'
        base_speaker_tts.tts(request.text, src_path, speaker=request.style, language='English', speed=1.0)

        # Run the tone color converter
        encode_message = "@MyShell"
        tone_color_converter.convert(
            audio_src_path=src_path,
            src_se=source_se,
            tgt_se=target_se,
            output_path=save_path,
            message=encode_message)

        return FileResponse(save_path, media_type="audio/wav")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
